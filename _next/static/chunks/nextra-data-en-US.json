{"/api_details":{"title":"API","data":{"":"Submodule doesn't come with a lot of API","executor#Executor":"Executor is the heart of submodule. An executor is a value/promise wrapper providing certain chain-operations","executorget#executor.get":"Get is the async method to help you get the value out of the Executor\nconst a = create(() => 'a')\nawait a.get() // will get 'a'","executorexecute#executor.execute":"Chain the execution\nconst a = create(() => 'a')\n\nconst x = await a.execute(v => {\n// v is 'a'\n})","executorprepare#executor.prepare":"Prepare a function.\nThe 1st parameter will be the executor value.\nThe 2nd parameter is the magic parameter.\nResult is the function where the only parameter is expected to be the type of the 2nd parameter\n\nUsecase, prepare is normally use to handle framework callbacks\nconst a = create(() => 'a')\nconst fn = a.prepare<[Request]>((v, i) => {\n//                                ^? Request\n//                             ^? 'a'\n})\n\nfn(request)\n// ^? Request\nFrom v4.4, prepare also supports variadic parameters\nconst a = create(() => 'a')\nconst fn = a.prepare<[Request, Response]>((v, req, res) => {\n//                                          ^? Request\n//                                               ^? Response\n})\n\nfn(request, response)","creation-api#Creation API":"","value#value":"Value accepts and value and wrap it in an executor\nconst a = value('a')\n\nawait a.get() // returns 'a'","from#from":"Link executor together\nconst a = value('a')\n\nconst b: Executor<...> = from(a).provide((v) => {\n//                                      ^? 'a'\n})","combine#combine":"Combine executor together\nconst a = value('a')\nconst b = value('b')\n\nconst c: Executor<{ a: string, b: string }> = combine({ a, b })","create#create":"Provide a value in the future via a callback. The value will be actualized when needed and depending\nconst a = create(() => 'a')\n\nawait a.get() // returns 'a'\nYou can also create an executor with dependency, similar to from\nconst a = create(() => 'a')\n\nconst b = create((v) => { ... }, a)\nconst b = from(a).provide((v) => { ... })\nYou can also create a non-cache provider by setting mode\nconst a = create(() => /** random number */)\nawait a.get() // always same value\nawait a.get() // always same value\nawait a.get() // always same value\n\nconst b = create(() => /** random number */, undefined, { mode: 'prototype' })\nawait b.get() // always different value\nawait b.get() // always different value\nawait b.get() // always different value"}},"/composition":{"title":"Composition","data":{"":"Composition makes the library's DX\nimport { create, combine } from \"@submodule/core\"\n\nconst config = create(async () => {\n// load config from YAML\n// validate configuration ...\nreturn { mongoDB: { ...mongoConfig }, fastify: {...fastifyConfig } }\n})\n\nconst mongoService = create(async (config) => {\nreturn mongo.connect(config.mongoDb)\n}, config)\n\nconst userService = create(async (mongoDb) => {\nreturn {\ncreateUser: ...,\nlistUsers: ...\nremoveUser: ...\n}\n}, mongoService)\n\nconst projectService = create(async (mongoDb) => {\nreturn {\ncreateProject: ...,\nlistProjects: ...\nremoveProject: ...\n}\n}, mongoService)\n\nconst services = combine({ userService, projectService })\n\nconst result = await from(services).execute(({ userService, projectService }) => {\n// do whatever you like with services any where\n})"}},"/concepts":{"title":"Concepts","data":{"":"Submodule is built around a function first-class support. It utilizes nature of functions to\nShare configuration, services\nCaching\nComposition\n\nAs such, submodule can be used to reuse configuration, functionality, group of services, group of codes. As they are all functions, they encourage testability and reusability"}},"/":{"title":"Simplify Service Lifecycle Management in Node.js with Submodule","data":{"":"Effortlessly manage the lifecycle of your services in Node.js with Submodule, a lightweight and versatile library designed to streamline service management. Say goodbye to complex dependency handling, configuration management, and testing challenges.","clear-structure-easy-management#Clear Structure, Easy Management":"Organize services with ease: Wrap your service creation functions and chain them together for a clear and organized structure.\nSimplify complex dependencies: Manage and understand intricate dependencies between services more effectively.\nSeamlessly integrate with your framework: Bring Submodule into your existing frameworks and utilize its power wherever you have an async function.\nServerless: Initialize what function needs, not what framework wants","streamlined-testing#Streamlined Testing":"Flexible testing environment: Easily change dependencies for testing purposes, promoting testability and isolation.\nTestable code chunks: Organize your code into smaller, testable units, facilitating robust testing.\nControlled lifecycle management: Implement unit tests and integration tests with ease by controlling the lifecycle of services.","lightweight-and-simple#Lightweight and Simple":"No unnecessary abstractions: Built in Typescript with zero dependencies, Submodule embraces the fundamental concept of functions without complex magic.\nQuick to understand and adopt: Experience the simplicity and elegance of Submodule, even for developers new to the library.\n\nDiscover a painless way to manage the lifecycle of your services in Node.js with Submodule. Enhance your development workflow, improve code maintainability, and simplify testing processes."}},"/running_mode":{"title":"Running mode","data":{"":"Submodule offers two initialization mode\nPrototype, where the result of the Provider will be created on every call\nSingleton, where the result of the Provider will be cached on the first call and won't be changed the whole lifecycle","singleton---default-mode#Singleton - default mode":"By default, singleton mode will be used\nimport { create } from \"@submodule/core\"\nconst config = create(() => { /** load things from yaml */ })\nthe YAML part will be loaded only once and to kept in memory, further access will return the same result","prototype#Prototype":"To create a new instance on call, prototype can be used\nimport { create } from \"@submodule/core\"\nconst config = create(() => { /** load things from yaml */ }, undefined, { mode: 'prototype' })\nAs such, every time config.execute(), the config will be loaded again.","in-use-with-combination#In use with combination":"When combine is used\nfrom(singleton).provide(() => {/**/}, { mode: 'prototype' })\nThe singleton will be created only once\nfrom(prototype).provide(() => {/**/}, { mode: 'prototype' })\nThen both submodule will be called many times"}},"/testing":{"title":"Testing","data":{"":"Javascript clousure is one of the common reason to make a function much less testable.\nSubmodule comes prepared. We introduced hijacking in version 4.1 of the library. As such, it is easy to change the actual implementation to a mock implementation to testFor example\nimport { create } from \"@submodule/core\"\ntype LogLevel = 'debug' | 'log' | 'error'\nconst config = create(() => ({ logLevel: 'debug' as LogLvel } /** imagine this config is loaded from .env */))\n\nconst logger = create((config) => {\nreturn (...msgs: string[]) => {\nif (config.logLevel === 'debug') {\n...\n} else if ...\n}\n}, config)\nAs you see from the code, the implementation of the logger heavy dependent on the config value.\nTo test, you can easily extract the implementation of logger then write unit test for it, sometime, it is just a hassle to do sometimeInstead, you can also control the transfered config using hijacking\nimport { value } from \"@submodule/core\"\nlogger._inject(value({ logLevel: 'error' })\nWith this, the dependent value will be as fed and you can simulate other cases"}},"/typescript":{"title":"Typescript support","data":{"":"The library is built on Typescript. As such, all of operations are comes with well type supporting"}}}