{"/concepts":{"title":"Concepts","data":{"":"Submodule is all about functions, and Typescript. As all of Submodule operations are just functions, they are easy to be reusable, easy to be tested, and be shared\nSubmodule build around two fundamental operations of an application","configuration#Configuration":"Configuration should be treated better, as such, Submodule provides a dedicated area where Configuration is setup, load and be reuseable.Providing configuration is as easy as providing an asynchronos function, and that's it, whatever is the result of the function will be through the application. As such, it opens up a free space for you to utilize whatever is needed to load configuration accordingly. YAML, dot-env etc, you named itAn example of configuration\nimport { prepareExecutable } from \"@submodule/core\"\nimport chalk from \"chalk\"\n\nconst { execute } = prepareExecutable({\nasync createConfig() {\nconst color = chalk[process.env.LOG_COLOR] || chalk.green\n\nreturn { color }\n},\ncreateServices({ config }) {\nreturn {\nlog(...args) {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}\n}\n})\n\nexecute(( { services } ) => {\nservices.log('hello', 'world')\n})","services#Services":"Services are reuslable service, normally it would share few characateristics\nKind of expensive and slow to start up, as such, it isn't meant to be recreated too many times\nWill have certain dependencies on configuration or on other services\n\nAn example of configuration\nimport { prepareExecutable } from \"@submodule/core\"\nimport chalk from \"chalk\"\n\nconst { execute } = prepareExecutable({\nasync createConfig() {\nconst color = chalk[process.env.LOG_COLOR] || chalk.green\n\nreturn { color }\n},\ncreateServices({ config }) {\nreturn {\nlog(...args) {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}\n}\n})\n\nexecute(( { services } ) => {\nservices.log('hello', 'world')\n})","executable#Executable":"Once you have set up your configuration and services, it is the time to create your function; and normally, you want to use defined services in your function.\nDoing so is rather simple\n\n\nconst { execute } = prepareExecutable\n// remaining part of the implementation...\n\nexecute(({ services }) => {\n// using services\nservices.log('hello', 'world')\n})\n\n\n\nconst { prepare } = prepareExecutable\n// remaining part of the implementation...\n\nconst log = prepare(({ services }, input) => {\n// using services with parameter\nservices.log(input)\n})\n\nlog('hello world')"}},"/":{"title":"Why Submodule?","data":{"":"Submodule is the simpliest possible IOC using function. As the currency in Submodule are all functions, Submodule gives a lot of flexibility and reusability to the library users","1-minute-example#1 minute example":"","install-dependencies#Install dependencies":"npm install @submodule/core chalk","write-your-color-app#Write your color app":"import { prepareExecutable } from \"@submodule/core\"\nimport chalk from \"chalk\"\n\nconst { execute } = prepareExecutable({\ncreateConfig() {\nconst color = chalk[process.env.LOG_COLOR] || chalk.green\n\nreturn { color }\n},\ncreateServices({ config }) {\nreturn {\nlog(...args) {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}\n}\n})\n\nexecute(( { services } ) => {\nservices.log('hello', 'world')\n})","execute-code#Execute code":"node main.mjs # should return hello world in green\nLOG_COLOR=red node main.mjs # should return hello world in red"}},"/typescript":{"title":"Typescript support","data":{"":"Submodule comes with tight typescript integration. There are few quality of life factor for your integration","auto-inferring-types#Auto-inferring types":"Submodule function supports type inteference in the submodule definition\nprepareExecutable({\ncreateConfig() {\nconst color = chalk[process.env.LOG_COLOR] || chalk.green\n\nreturn { color }\n},\ncreateServices({ config }) {\n//             ^? { color: ...chalk function}\nreturn {\nlog(...args) {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}\n}\n})"}}}