{"/composition":{"title":"Composition","data":{"":"Composition makes the library's DX\nimport { prepareExecutable, compose } from \"@submodule/core\"\n\nconst config = prepareExecutable(async () => {\n// load config from YAML\n// validate configuration ...\nreturn { mongoDB: { ...mongoConfig }, fastify: {...fastifyConfig } }\n})\n\nconst mongoService = prepareExecutable(async (config) => {\nreturn mongo.connect(config.mongoDb)\n}, { initArgs: config.get })\n\nconst userService = prepareExecutable(async (mongoDb) => {\nreturn {\ncreateUser: ...,\nlistUsers: ...\nremoveUser: ...\n}\n}, { initArgs: mongoService.get })\n\nconst projectService = prepareExecutable(async (mongoDb) => {\nreturn {\ncreateProject: ...,\nlistProjects: ...\nremoveProject: ...\n}\n}, { initArgs: mongoService.get })\n\nconst services = compose({ userService, projectService })\n\nconst result = await services.execute(({ userService, projectService }) => {\n// do whatever you like with services any where\n})"}},"/concepts":{"title":"Concepts","data":{"":"Submodule is built around a function first-class support. It utilizes nature of functions to\nShare configuration, services\nCaching\nComposition\n\nAs such, submodule can be used to reuse configuration, functionality, group of services, group of codes. As they are all functions, they encourage testability and reusability"}},"/":{"title":"Why Submodule?","data":{"":"Simpliest, yet very flexibile Inversion of Control within 100 lines of codeWhat Submodule brings?\n✅ Typescript out of the box\n✅ Browser, Node.js, Deno, Bun, you name it\n✅ Easy to understand\n✅ No magic, no codegen\n✅ Integratable with all frameworks, bring your Next.js, Remix, Solid, Fastify, Express","1-minute-example#1 minute example":"","install-dependencies#Install dependencies":"npm install @submodule/core chalk","write-your-color-app#Write your color app":"import { prepareExecutable } from \"@submodule/core\"\nimport chalk from \"chalk\"\n\nconst config = prepareExecutable(() => ({ color: process.env.LOG_COLOR || chalk.green }))\n\nexport const logger = prepareExecutable((config) => {\nreturn (...args) => {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}, { initArgs: config.get })\n\nimport { logger } from \"./main\"\n\n// access from everywhere\nlogger.execute(logService => {\nlogService.log('hello', 'world')\n})","execute-code#Execute code":"node main.mjs # should return hello world in green\nLOG_COLOR=red node main.mjs # should return hello world in red"}}}