{"/composition":{"title":"Composition","data":{"":"Composition makes the library's DX\nimport { create, combine } from \"@submodule/core\"\n\nconst config = create(async () => {\n// load config from YAML\n// validate configuration ...\nreturn { mongoDB: { ...mongoConfig }, fastify: {...fastifyConfig } }\n})\n\nconst mongoService = create(async (config) => {\nreturn mongo.connect(config.mongoDb)\n}, config)\n\nconst userService = create(async (mongoDb) => {\nreturn {\ncreateUser: ...,\nlistUsers: ...\nremoveUser: ...\n}\n}, mongoService)\n\nconst projectService = create(async (mongoDb) => {\nreturn {\ncreateProject: ...,\nlistProjects: ...\nremoveProject: ...\n}\n}, mongoService)\n\nconst services = combine({ userService, projectService })\n\nconst result = await from(services).execute(({ userService, projectService }) => {\n// do whatever you like with services any where\n})"}},"/concepts":{"title":"Concepts","data":{"":"Submodule is built around a function first-class support. It utilizes nature of functions to\nShare configuration, services\nCaching\nComposition\n\nAs such, submodule can be used to reuse configuration, functionality, group of services, group of codes. As they are all functions, they encourage testability and reusability"}},"/":{"title":"Why Submodule?","data":{"":"Simpliest, yet very flexibile Inversion of Control within 100 lines of codeWhat Submodule brings?\n✅ Typescript out of the box\n✅ Browser, Node.js, Deno, Bun, you name it\n✅ Easy to understand\n✅ No magic, no codegen\n✅ Integratable with all frameworks, bring your Next.js, Remix, Solid, Fastify, Express","version-40#Version 4.0":"Submodule 4.0 comes with a much lighter set of API to over-simplify operation","1-minute-example#1 minute example":"","install-dependencies#Install dependencies":"npm install @submodule/core chalk","write-your-color-app#Write your color app":"import { create } from \"@submodule/core\"\nimport chalk from \"chalk\"\n\nconst config = create(() => ({ color: process.env.LOG_COLOR || chalk.green }))\n\n// craft an utilities with dependencies\nexport const logger = create((config) => {\nreturn (...args) => {\nconsole.log(...args.map(arg => config.color(arg)))\n}\n}, config)\n\nimport { logger } from \"./main\"\nimport { create } from \"@submodule/core\"\n\n// access from everywhere\nfrom(logger).execute(log => {\nlog('hello', 'world')\n})","execute-code#Execute code":"node main.mjs # should return hello world in green\nLOG_COLOR=red node main.mjs # should return hello world in red"}},"/running_mode":{"title":"Running mode","data":{"":"Submodule offers two initialization mode\nPrototype, where the result of the Provider will be created on every call\nSingleton, where the result of the Provider will be cached on the first call and won't be changed the whole lifecycle","singleton---default-mode#Singleton - default mode":"By default, singleton mode will be used\nimport { create } from \"@submodule/core\"\nconst config = create(() => { /** load things from yaml */ })\nthe YAML part will be loaded only once and to kept in memory, further access will return the same result","prototype#Prototype":"To create a new instance on call, prototype can be used\nimport { create } from \"@submodule/core\"\nconst config = create(() => { /** load things from yaml */ }, undefined, { mode: 'prototype' })\nAs such, every time config.execute(), the config will be loaded again.","in-use-with-combination#In use with combination":"When combine is used\nfrom(singleton).provide(() => {/**/}, { mode: 'prototype' })\nThe singleton will be created only once\nfrom(prototype).provide(() => {/**/}, { mode: 'prototype' })\nThen both submodule will be called many times"}},"/testing":{"title":"Testing","data":{"":"Javascript clousure is one of the common reason to make a function much less testable.\nSubmodule comes prepared. We introduced hijacking in version 4.1 of the library. As such, it is easy to change the actual implementation to a mock implementation to testFor example\nimport { create } from \"@submodule/core\"\ntype LogLevel = 'debug' | 'log' | 'error'\nconst config = create(() => ({ logLevel: 'debug' as LogLvel } /** imagine this config is loaded from .env */))\n\nconst logger = create((config) => {\nreturn (...msgs: string[]) => {\nif (config.logLevel === 'debug') {\n...\n} else if ...\n}\n}, config)\nAs you see from the code, the implementation of the logger heavy dependent on the config value.\nTo test, you can easily extract the implementation of logger then write unit test for it, sometime, it is just a hassle to do sometimeInstead, you can also control the transfered config using hijacking\nimport { value } from \"@submodule/core\"\nlogger.inject(value({ logLevel: 'error' })\nWith this, the dependent value will be as fed and you can simulate other cases"}},"/typescript":{"title":"Typescript support","data":{"":"The library is built on Typescript. As such, all of operations are comes with well type supporting"}}}