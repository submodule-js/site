{"/concepts/server_executable":{"title":"Server Executable","data":{"":"Submodule offers two different operation models.","server-mode#Server mode":"Server mode situables for an application that relies on Submodule to manage the whole life cycle. The whole operations isn't likely to go without Submodule involvement.A good example would be a typical any Node.js web application like Express. If you decide Submodule to manage life cycle of Express life cycle, then the Server is the one for you","executable-mode#Executable mode":"On the opposite, where you have a little control over the life cycle of the application, you may want Submodule to operate just like any other Function. As such, you still can utilize all of Submodule concept. All backend operations can be used as easy as calling a functionA good example of Executable would be an integration with Next.js. Nextjs is a opinionated development model with a lot of magic behind the scene to offer good DX. To integrate with Next.js, Submodule rather be operated in Executable mode, then we can trigger the function just be calling the function within Next.js API handler"}},"/concepts/type_shapes":{"title":"Type Shapes","data":{"":"Most pieces of Submodule requires a shape. A shape reflects how the application is designed and used. There are likely few types of Shapes\n\nConfiguration is an object that holds application configuration. It reflected using the typescript code indicating what configuration looks like\nConfiguration creation function is the function that responsible to load configuration from different sources and making sure configuration in write shape\ntype Config = {\nmongoUrl: string\nusername?: string\npassword?: string\n}\n\nfunction createConfig(): Config {\nreturn {\nmongoUrl: process.env.MONGO_URL || 'mongodb://mongodb0.example.com:27017',\nusername: process.env.MONGO_USER,\npassword: process.env.MONGO_PASSWORD\n}\n}\nIf you are not font of process.env, you can quickly swap with with .env or .yaml without losing type comprehension\n\nServices is an object that holds shared services to be used in the application. Most of services today will require a certain set of configuration to function correctly\nService creation function is a function that takes an config object as input and responsible to resolve service dependencies\nexport const mongoService = async (mongoServiceParam: {\nmongoUrl: string,\nmongoUser?: string,\nmongoPassword?: string\n}) => {\nconst mongoClient = // create mongoCient\nreturn { mongoClient }\n}\n\nexport type MongoService = Awaited<ReturnType<typeof mongoService>>\n\nexport const userService = async (userServiceParam: {\nmongoClient: MongoClient\n}) => {\nreturn {\n// userservice content\n}\n}\n\nexport type UserService = Awaited<ReturnType<typeof userService>>\n\ntype Config = {\nmongoUrl: string\nmonogUser?: string\nmongoPassword?: string\n}\n\ntype Services = {\nmongoClient: MongoClient\nuserService: UserService\n}\n\nfunction createConfig(): Config {\nreturn {\nmongoUrl: // mongourl\n}\n}\n\nasync function createServices({ config }): Promise<Services> {\nconst mongoClient = await mongoService({ ... config })\nconst userService = await userService({ mongoClient })\nreturn {\nmongoClient, userService\n}\n}\n\n\nRoute Module is the concept where it is getting more complex, because it is up to you to design what your coding style looks like.\nNormally, an application composes by a part of\nSetting up (configuration, shared services, framework specific settings etc)\nand your implementations, per route, per pages etc\n\nFor example, a typical web server will have handlers for mulitple paths, each path implemention is what we called Route Module. Why it is important? Because this is the piece where most pieces of your applications are glued togetherBy defining a shape of a Route Module, you settle around 80% of your preparation\ntype RouteModule = {\ndefault: ( // assume we'll use `import` to load module\ncallContext: { config: Config, services: Services, context: Context},\ninput: Input\n) => Output | Promise<Output>\n}\nThis means, every implementation should be in a form a function. Each function will receive the first argument of callContext and the second argument is an input\n\nContext is an object that holds necessary information per operation. And that is also what makes Context different to Services.Context, per request. Services, per applicationIn a normal web server, Context should hold Request and Response\ntype Context = {\nrequest: Request\nresponse: Response\n}\n\n\nRoute is the Submodule Computation unit. Route will bridge between\nContext, a per operation content\nwith setting up structure (Config, Services)\nand user-defined computation unit - your handlers\n\nTo create a route, we'll need a createRoute function\ntype RouteLike = {\nhandle: (context: Context) => Promise<unknown>\nrouteName: string\nrouteModule: RouteModule\n}\n\nasync function createRoute({ routeName, routeModule }): RouteLike {\nreturn {\nasync handle(context) {\n// do something with routeModule\n// for example\nconst result = await routeModule.default( // ... to match the shape of the function )\n\n// do something with the result\nreturn result\n},\nrouteName, // if you want to change the name of the path\nrouteModule\n}\n}\nThe nature of the handle function gives us a nature interpretion layer just right before and after an execution.You can catch error, transform input, transform output, adapt whatever is needed to the style you like. That gives whole dynamic to you and your team coding style"}},"/getting_started":{"title":"Getting Started","data":{"":""}},"/":{"title":"Why Submodule?","data":{"":"Welcome to the Submodule documentation! Submodule is a powerful and flexible Javascript/Typescript library that helps you enforce a good structure for your Node.js backend applications. Whether you're building a command-line interface (CLI) for migrations or a full-fledged backend, Submodule can adapt to your needs by acting as a composer that connects all the reusable functions in your project.Submodule is designed to be opinionated, but its implementation details are entirely up to you. This means you can bring your own configuration loader, choose any Javascript web server or framework, and Submodule will seamlessly integrate with your project.In this documentation, you'll learn how to install and use Submodule, as well as explore its core concepts and advanced features. We'll also cover how to integrate Submodule into your existing projects and answer frequently asked questions."}},"/putting_together":{"title":"Putting Together","data":{"":"Submodule is different to what you used to use. Submodule plays as a glue, glueing all components together so you don't have to think about it\nThis is what we would suggest to use Submodule","define-shape-of-configuration-services-and-context#Define shape of configuration, services and context":"Define the shapes of what is meaningful for your application\nConfiguration, what needs to be configurable\nServices, what services will be reused","choose-a-route-module-style#Choose a Route Module style":"Route Module is an important unit for you to manage the project's coding style. Choose it wisely so it seems naturally fit into your team's comprehension\nThis is important because that's how you pass config, service and input to every functions","choose-an-operation-model#Choose an operation model":"If you have full control over lifecycle of the application, you may want to use Server mode. If you are in an serverless environment or integrating Submodule to other framework, you may want to stick with Executable","implement-details-following-shape-mentioned#Implement details following shape mentioned":"","connect-everything#Connect everything":""}},"/getting_started/executable":{"title":"Executable","data":{"":"Executable mode is the most flexible way for you to integrate submodule with your application.","install-submodulecore-using-your-prefered-package-manager#install @submodule/core using your prefered package manager":"npm install @submodule/core\n\n\n\nyarn install @submodule/core\n\n\n\npnpm install @submodule/core","prepare-runtime-environment-optional#prepare runtime environment (optional)":"We use tsx here to simplify the process, but it will be the same for all runner\n\n\nnpm install -D tsx\n\n\n\nyarn install -D tsx\n\n\n\npnpm install -D tsx\n\n\n\n{\n\"compilerOptions\": {\n\"moduleResolution\": \"node\"\n}\n}","helloworld#hello.world":"import { builder } from \"@submodule/core\"\n\ntype Config = { }\n\nexport const exec = builder()\n.config<{ debug: boolean }>()\n.services<{ log: (...args: any[]) => void }>()\n.prepareExecutable({\nasync createConfig() {\nreturn { debug: Boolean(process.env.DEBUG )}\n},\nasync createServices({ config }) {\n// ^? { debug: boolean }\nreturn {\nlog(...args) {\n//     ^? any[]\nif (config.debug) {\nconsole.log.apply(console, args)\n}\n}\n}\n}\n}, undefined)\n\nimport { exec } from \"./submodule\"\n\nexec(({ services }) => {\nservices.log('hello', 'world')\n})","enjoy#enjoy":"npx tsx main.ts\n# should return nothing\n\nDEBUG='true' tsx main.tsx\n# should print out hello world"}}}