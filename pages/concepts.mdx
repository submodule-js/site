import { Tabs, Tab } from "nextra-theme-docs"

# Concepts

Submodule is all about functions, and Typescript. As all of Submodule operations are just functions, they are easy to be reusable, easy to be tested, and be shared
Submodule build around two fundamental operations of an application

## Configuration
Configuration should be treated better, as such, Submodule provides a dedicated area where Configuration is setup, load and be reuseable. 

Providing configuration is as easy as providing an asynchronos function, and that's it, whatever is the result of the function will be through the application. As such, it opens up a free space for you to utilize whatever is needed to load configuration accordingly. YAML, dot-env etc, you named it

An example of configuration
```javascript {5-9} filename="main.mjs" copy
import { prepareExecutable } from "@submodule/core"
import chalk from "chalk"

const { execute } = prepareExecutable({
  async createConfig() {
    const color = chalk[process.env.LOG_COLOR] || chalk.green

    return { color }  
  },
  createServices({ config }) {
    return {
      log(...args) {
        console.log(...args.map(arg => config.color(arg)))
      }
    }
  }
})

execute(( { services } ) => {
  services.log('hello', 'world')
})
```

## Services
Services are reuslable service, normally it would share few characateristics
- Kind of expensive and slow to start up, as such, it isn't meant to be recreated too many times
- Will have certain dependencies on configuration or on other services

An example of configuration
```javascript {10-16} filename="main.mjs" copy
import { prepareExecutable } from "@submodule/core"
import chalk from "chalk"

const { execute } = prepareExecutable({
  async createConfig() {
    const color = chalk[process.env.LOG_COLOR] || chalk.green

    return { color }  
  },
  createServices({ config }) {
    return {
      log(...args) {
        console.log(...args.map(arg => config.color(arg)))
      }
    }
  }
})

execute(( { services } ) => {
  services.log('hello', 'world')
})
```

## Executable
Once you have set up your configuration and services, it is the time to create your function; and normally, you want to use defined services in your function.
Doing so is rather simple

<Tabs items={['execute directly', 'reusable function']}>
  <Tab>
    ```javascript {1, 6}
      const { execute } = prepareExecutable 
        // remaining part of the implementation...

      execute(({ services }) => {
        // using services
        services.log('hello', 'world')
      })
    ```
  </Tab>
  <Tab>
    ```javascript {1, 4, 9}
      const { prepare } = prepareExecutable 
        // remaining part of the implementation...

      const log = prepare(({ services }, input) => {
        // using services with parameter
        services.log(input)
      })

      log('hello world')
    ```
  </Tab>
</Tabs>