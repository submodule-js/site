import { Tab, Tabs } from 'nextra-theme-docs'

Most pieces of Submodule requires a shape. A shape reflects how the application is designed and used. There are likely few types of Shapes

<Tabs items={[
  'configuration', 
  'services', 
  'routeModule',
  'context',
  'route'
]}>
  <Tab>
    *Configuration* is an object that holds application configuration. It reflected using the typescript code indicating what configuration looks like
    Configuration creation function is the function that responsible to load configuration from different sources and making sure configuration in write shape
    ```typescript
    type Config = {
      mongoUrl: string 
      username?: string 
      password?: string 
    }

    function createConfig(): Config {
      return {
        mongoUrl: process.env.MONGO_URL || 'mongodb://mongodb0.example.com:27017',
        username: process.env.MONGO_USER,
        password: process.env.MONGO_PASSWORD
      }
    }
    ```

    If you are not font of `process.env`, you can quickly swap with with `.env` or `.yaml` without losing type comprehension
  </Tab>
  <Tab>
    *Services* is an object that holds shared services to be used in the application. Most of services today will require a certain set of configuration to function correctly
    Service creation function is a function that takes an config object as input and responsible to resolve service dependencies

    ```typescript filename="mongo.service.ts"
    export const mongoService = async (mongoServiceParam: { 
      mongoUrl: string, 
      mongoUser?: string, 
      mongoPassword?: string
    }) => {
      const mongoClient = // create mongoCient
      return { mongoClient }
    }

    export type MongoService = Awaited<ReturnType<typeof mongoService>>
    ```

    ```typescript filename="user.service.ts"
    export const userService = async (userServiceParam: { 
      mongoClient: MongoClient
    }) => {
      return { 
        // userservice content
      }
    }

    export type UserService = Awaited<ReturnType<typeof userService>>
    ```

    ```typescript filename="submodule.types.ts"
    type Config = { 
      mongoUrl: string
      monogUser?: string
      mongoPassword?: string
    }

    type Services = {
      mongoClient: MongoClient
      userService: UserService
    }
    ```
    

    ```typescript filename="submodule.ts"
    function createConfig(): Config {
      return {
        mongoUrl: // mongourl
      }
    }

    async function createServices({ config }): Promise<Services> {
      const mongoClient = await mongoService({ ... config })
      const userService = await userService({ mongoClient })
      return {
        mongoClient, userService
      }
    }
    ```
    
  </Tab>
  <Tab>
    *Route Module* is the concept where it is getting more complex, because it is up to you to design what your coding style looks like.
    Normally, an application composes by a part of 
    - Setting up (configuration, shared services, framework specific settings etc)
    - and your implementations, per route, per pages etc

    For example, a typical web server will have handlers for mulitple paths, each path implemention is what we called *Route Module*. Why it is important? Because this is the piece where most pieces of your applications are glued together

    By defining a shape of a Route Module, you settle around 80% of your preparation

    ```typescript filename="submodule.types.ts"
    type RouteModule = {
      default: ( // assume we'll use `import` to load module
        callContext: { config: Config, services: Services, context: Context}, 
        input: Input
      ) => Output | Promise<Output>
    }
    ```

    This means, every implementation should be in a form a function. Each function will receive the first argument of callContext and the second argument is an input 
  </Tab>
  <Tab>
    *Context* is an object that holds necessary information per operation. And that is also what makes Context different to `Services`. 
    
    Context, per request. Services, per application

    In a normal web server, Context should hold Request and Response 

    ```typescript filename="submodule.types.ts"
    type Context = {
      request: Request
      response: Response
    }
    ```
  </Tab>
  <Tab>
    *Route* is the Submodule Computation unit. Route will bridge between
    - Context, a per operation content
    - with setting up structure (Config, Services)
    - and user-defined computation unit - your handlers

    To create a route, we'll need a createRoute function

    ```typescript
    type RouteLike = {
      handle: (context: Context) => Promise<unknown>
      routeName: string
      routeModule: RouteModule
    }

    async function createRoute({ routeName, routeModule }): RouteLike {
      return {
        async handle(context) {
          // do something with routeModule
          // for example
          const result = await routeModule.default( // ... to match the shape of the function )

          // do something with the result
          return result
        },
        routeName, // if you want to change the name of the path
        routeModule 
      }
    }
    ```

    The nature of the `handle` function gives us a nature interpretion layer just right before and after an execution. 
    
    You can catch error, transform input, transform output, adapt whatever is needed to the style you like. That gives whole dynamic to you and your team coding style
  </Tab>
</Tabs>